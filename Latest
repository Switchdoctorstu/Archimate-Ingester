# ArchiMate ingestor By Stuart Oldfield
VERSIONTEXT=" Version: 10.1 3d"
# - Load .archimate XML
# - Quick-add elements (type/name/description) -> appends to Paste Area
# - Paste Area (text list) including relationships -> staged elements & relationships
# - Insert commits staged lines into the model, placing elements in the correct folder
# - Relationships are placed in Relations folder and diagram objects + connections are created in an "Auto Diagram"
# - Tree view shows the model; selecting a node shows details
# - Save writes a valid .archimate file with proper namespaces
# - Live XML output panel always shows current model

# TODO:
# - [ ] Improve error handling and user notifications
# - [ ] Optimize XML handling and improve performance for large models
# - [ ] VR ?
# - [ ] Add support for custom element attributes and more relationship types
# - [ ] Allow editing of existing elements and relationships
# - [ ] Implement import and export of views/diagrams
# - [ ] Offer multiple file save formats and settings for export customization
# - [ ] Improve documentation and user guidance within the app

# ---- Imports ----
import tkinter as tk
from tkinter import simpledialog
from tkinter import ttk, filedialog, messagebox
import xml.etree.ElementTree as ET
import uuid
import copy
import os
from xml.dom import minidom
import datetime
import csv

from DBDriver import ArchiMateDB, generate_id
from ThreeDViewer import ThreeDViewer
import google.generativeai as genai # You may need to run: pip install google-generativeai
from config import FOLDER_MAP, COMMON_TYPES, RELATIONSHIP_TYPES, RELATIONSHIP_RULES, AUTOCOMPLETE_RULES


def list_gemini_models():
    """Fetch list of available Gemini models for dropdown."""
    try:
        client = genai.Client()
        models = client.models.list()
        return [m.name for m in models if "gemini" in m.name]
    except Exception as e:
        print(f"⚠️ Could not fetch model list: {e}")
        # Fallback: common known models
        return ["models/gemini-2.5-pro", "models/gemini-2.5-flash", "models/gemini-2.0-flash"]

# ---- Gemini API Key ----
# IMPORTANT: Replace "YOUR_API_KEY" with your actual Google AI Studio API key.
# Keep this key secure and do not commit it to public repositories.


# ---- Namespaces ----
XSI = "http://www.w3.org/2001/XMLSchema-instance"
ARCHIMATE = "http://www.archimatetool.com/archimate"
ET.register_namespace("xsi", XSI)
ET.register_namespace("archimate", ARCHIMATE)



def get_build_version():
    try:
        # Use the file's last modification time as the build date
        build_time = os.path.getmtime(__file__)
        build_dt = datetime.datetime.fromtimestamp(build_time)
        return build_dt.strftime("Build %Y-%m-%d %H:%M:%S")
    except Exception:
        return "Build date unknown"

# Map ArchiMate element short types to Folder name
# --- All large configuration dictionaries have been moved to config.py ---


class ArchiIngestorApp:
    def __init__(self, root):
        self.root = root
        version_str = get_build_version()
        self.root.title(f"ArchiMate Ingestor ({VERSIONTEXT }) ({version_str})")
        self.root.geometry("1400x900")

        self.tree = None
        self.model = None
        self.dirty = False # Track if model has unsaved changes
        self.history = []
        self.filepath = None
        self.element_db = {}
        self.relationship_counts = {}
        self.relationship_map = {} # Cache for fast relationship lookups
        self.depth_var = tk.IntVar(value=1)
        self.viewer = ThreeDViewer(self) # Create an instance of the 3D viewer

        # --- DB Integration ---
        self.db_manager = None
        self.db_filepath = None
        self.current_mode = 'file' # 'file' or 'db'

        self.build_gui()
        self.default_bg = self.open_button.cget("background") # Get default button background
        self.update_button_states() # Initial state update

    def build_gui(self):
        toolbar = tk.Frame(self.root)
        toolbar.pack(fill="x", pady=4)
        self.open_button = tk.Button(toolbar, text="Open .archimate", command=self.open_file)
        self.open_button.pack(side="left", padx=4)
        self.save_button = tk.Button(toolbar, text="Save As XML...", command=self.save_as)
        self.save_button.pack(side="left", padx=4)

        # --- DB Buttons ---
        self.open_db_button = tk.Button(toolbar, text="Open DB", command=self.open_database)
        self.open_db_button.pack(side="left", padx=4)
        self.save_db_button = tk.Button(toolbar, text="Save to DB", command=self.save_to_database)
        self.save_db_button.pack(side="left", padx=4)

        self.export_csv_button = tk.Button(toolbar, text="Export to CSV", command=self.export_pivot_csv)
        self.export_csv_button.pack(side="left", padx=4)

        self.insert_button = tk.Button(toolbar, text="Insert (commit staged)", command=self.insert_from_paste)
        self.insert_button.pack(side="left", padx=4)
        self.undo_button = tk.Button(toolbar, text="Undo", command=self.undo)
        self.undo_button.pack(side="left", padx=4)
        self.refresh_button = tk.Button(toolbar, text="Refresh Tree", command=self.refresh_tree)
        self.refresh_button.pack(side="left", padx=4)
        self.view3d_button = tk.Button(toolbar, text="Show 3D View", command=lambda: self.viewer.show_3d_view(self.depth_var.get()))
        self.view3d_button.pack(side="left", padx=4)

        tk.Label(toolbar, text="3D Depth:").pack(side="left", padx=(10, 2))
        depth_slider = tk.Scale(toolbar, from_=0, to=5, orient=tk.HORIZONTAL, variable=self.depth_var, length=80)
        depth_slider.pack(side="left", padx=2)
        
        self.clean_button = tk.Button(toolbar, text="Clean & Validate", command=self.validate_and_clean_relationships)
        self.clean_button.pack(side="left", padx=4)
        # Add the conservative autocomplete button
        self.autocomplete_button = tk.Button(toolbar, text="Autocomplete", command=self.autocomplete_model_conservative)
        self.autocomplete_button.pack(side="left", padx=4)
        self.catalog_button = tk.Button(toolbar, text="Catalog", command=self.show_catalog_window)
        self.catalog_button.pack(side="left", padx=4)
        # Add conservative validation button
        #tk.Button(toolbar, text="Validate", command=self.validate_relationships_conservative).pack(side="left", padx=4)

        main = tk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main.pack(fill="both", expand=True, padx=6, pady=6)

        # Left: Tree, details, XML
        left_frame = tk.Frame(main)
        main.add(left_frame, stretch="always", minsize=400)

        # --- Search and Tree Frame ---
        tree_container = tk.Frame(left_frame)
        tree_container.pack(fill="x", pady=(0, 5))

        tk.Label(tree_container, text="Search:").pack(side="left", padx=(0, 5))
        self.search_var = tk.StringVar()
        self.search_entry = tk.Entry(tree_container, textvariable=self.search_var)
        self.search_entry.pack(side="left", fill="x", expand=True)
        self.search_var.trace_add("write", self.search_tree)

        tree_frame = tk.Frame(left_frame)
        tree_frame.pack(fill="both", expand=True)
        self.treeview = ttk.Treeview(tree_frame)
        self.treeview.pack(fill="both", expand=True, side="left")
        self.treeview.bind("<<TreeviewSelect>>", self.on_tree_select)
        tree_scroll = ttk.Scrollbar(left_frame, orient="vertical", command=self.treeview.yview)
        tree_scroll.pack(side="left", fill="y")
        self.treeview.configure(yscrollcommand=tree_scroll.set)
        details_frame = tk.Frame(left_frame)
        details_frame.pack(fill="x")
        tk.Label(details_frame, text="Selected Node Details:").pack(anchor="w")
        self.details_text = tk.Text(details_frame, height=7, state="disabled")
        self.details_text.pack(fill="both", expand=True)

        # XML Output Panel
        xml_frame = tk.LabelFrame(left_frame, text="Current Output XML")
        xml_frame.pack(fill="both", expand=True, padx=2, pady=2)
        self.xml_output_text = tk.Text(xml_frame, height=18, state="disabled", font=("Consolas", 9))
        self.xml_output_text.pack(fill="both", expand=True)

        # Right: Quick add, paste, preview
        right_frame = tk.Frame(main)
        main.add(right_frame, stretch="never", minsize=400)

        quick_frame = tk.LabelFrame(right_frame, text="Quick Add (appends to Paste Area)")
        quick_frame.pack(fill="x", padx=4, pady=4)
        tk.Label(quick_frame, text="Type:").grid(row=0, column=0, sticky="w")
        self.type_var = tk.StringVar()
        self.type_combo = ttk.Combobox(quick_frame, textvariable=self.type_var, values=COMMON_TYPES, width=30)
        self.type_combo.grid(row=0, column=1, sticky="we", padx=4, pady=2)
        self.type_combo.current(0)
        tk.Label(quick_frame, text="Name:").grid(row=1, column=0, sticky="w")
        self.name_entry = tk.Entry(quick_frame, width=60)
        self.name_entry.grid(row=1, column=1, sticky="we", padx=4, pady=2)
        tk.Label(quick_frame, text="Description:").grid(row=2, column=0, sticky="w")
        self.desc_entry = tk.Entry(quick_frame, width=60)
        self.desc_entry.grid(row=2, column=1, sticky="we", padx=4, pady=2)
        tk.Button(quick_frame, text="Add → Paste Area", command=self.quick_add_to_paste).grid(row=3, column=1, sticky="e", padx=4, pady=6)
        quick_frame.grid_columnconfigure(1, weight=1)
        # Gemini Frame
        gemini_frame = tk.LabelFrame(right_frame, text="Ask Gemini")
        gemini_frame.pack(fill="x", padx=4, pady=4)
        # --- Gemini Model Selection ---
        tk.Label(gemini_frame, text="Select Gemini Model:").pack(anchor="w")
        self.model_var = tk.StringVar()
        available_models = list_gemini_models()
        self.model_combo = ttk.Combobox(gemini_frame, textvariable=self.model_var, values=available_models, width=40)
        self.model_combo.pack(anchor="w", pady=2)
        if available_models:
            self.model_combo.current(0)  # select first by default

        self.gemini_prompt_text = tk.Text(gemini_frame, height=4, wrap="word")
        self.gemini_prompt_text.pack(fill="x", expand=True, padx=4, pady=(4,0))
        self.gemini_prompt_text.insert("1.0", "As a Planning Officer, what are the key technologies that will affect my role over the next 5 years and how can i best take advantage of them?")
        
        gemini_button_frame = tk.Frame(gemini_frame)
        gemini_button_frame.pack(fill="x", pady=4)

        tk.Label(gemini_button_frame, text="Context Strategy:").pack(side="left", padx=(4, 2))
        self.gemini_context_strategy_var = tk.StringVar(value="None (Stateless)")
        context_options = ["None (Stateless)", "Auto-Detect", "Full Model"]
        context_combo = ttk.Combobox(gemini_button_frame, textvariable=self.gemini_context_strategy_var, values=context_options, state="readonly", width=15)
        context_combo.pack(side="left", padx=2)

        self.gemini_generate_button = tk.Button(gemini_button_frame, text="Generate!", command=self.handle_ask_gemini)
        self.gemini_generate_button.pack(side="right", padx=4, pady=0)

        paste_frame = tk.LabelFrame(right_frame, text="Paste Area (text-based staging)")
        paste_frame.pack(fill="both", expand=True, padx=4, pady=4)
        tk.Label(paste_frame, text="One entry per line. Format examples:\nElement: Type | Name | description=...\nRelationship: AssignmentRelationship | SourceName | target=TargetName | description=...").pack(anchor="w")
        self.paste_text = tk.Text(paste_frame, height=14)
        self.paste_text.pack(fill="both", expand=True)
        self.paste_text.bind("<<Modified>>", self.on_paste_modified)
        paste_buttons = tk.Frame(paste_frame)
        paste_buttons.pack(fill="x")
        tk.Button(paste_buttons, text="Clear Paste Area", command=self.clear_paste).pack(side="left", padx=4, pady=4)
        tk.Button(paste_buttons, text="Parse Preview", command=self.update_staged_preview).pack(side="left", padx=4, pady=4)
        tk.Button(paste_buttons, text="3D Preview", command=self.viewer.show_staged_3d_preview).pack(side="left", padx=4, pady=4)

        preview_frame = tk.LabelFrame(right_frame, text="Staged Preview (XML snippets from paste area)")
        preview_frame.pack(fill="both", expand=True, padx=4, pady=4)
        self.preview_text = tk.Text(preview_frame, height=12, state="disabled")
        self.preview_text.pack(fill="both", expand=True)

        self.status_var = tk.StringVar(value="No file loaded.")
        status = tk.Label(self.root, textvariable=self.status_var, anchor="w")
        status.pack(fill="x")
    

        self.update_staged_preview()

    def update_button_states(self):
        """Updates the state and visual cues of toolbar buttons based on app state."""
        is_model_loaded = self.model is not None
        has_paste_text = self.paste_text.get("1.0", "end-1c").strip() != ""
        highlight_color = "gray80"  # Light gray for highlighting

        # Open button: Highlight if no model is loaded
        self.open_button.config(background=highlight_color if not is_model_loaded else self.default_bg)

        # Save button: Enable if model is loaded, highlight if dirty
        self.save_button.config(state=tk.NORMAL if is_model_loaded else tk.DISABLED)
        self.save_button.config(background=highlight_color if self.dirty else self.default_bg)

        # Insert button: Enable if model is loaded, highlight if there's text to insert
        self.insert_button.config(state=tk.NORMAL if is_model_loaded else tk.DISABLED)
        self.insert_button.config(background=highlight_color if has_paste_text and is_model_loaded else self.default_bg)

        # Undo button: Enable if there's history
        self.undo_button.config(state=tk.NORMAL if self.history else tk.DISABLED)

        # Other model-dependent buttons
        for btn in [self.refresh_button, self.view3d_button, self.clean_button, self.autocomplete_button, self.gemini_generate_button, self.catalog_button, self.save_db_button, self.export_csv_button]:
            btn.config(state=tk.NORMAL if is_model_loaded else tk.DISABLED)

    def show_catalog_window(self):
        """Creates a non-modal window to view and edit entities by type."""
        if self.model is None:
            messagebox.showwarning("No Model", "Please open a model file first.")
            return

        # Prevent multiple catalog windows
        if hasattr(self, 'catalog_win') and self.catalog_win.winfo_exists():
            self.catalog_win.lift()
            return

        self.catalog_win = tk.Toplevel(self.root)
        self.catalog_win.title("Entity Catalog Editor")
        self.catalog_win.geometry("800x600")

        # --- Get entity types from the current model ---
        entity_types = set()
        for el in self.model.findall(".//element"):
            el_type_full = el.get(f"{{{XSI}}}type", "")
            if el_type_full and "Relationship" not in el_type_full:
                entity_types.add(el_type_full.replace("archimate:", ""))
        
        sorted_types = sorted(list(entity_types))

        # --- Widgets ---
        top_frame = tk.Frame(self.catalog_win, padx=10, pady=10)
        top_frame.pack(fill="x")

        tk.Label(top_frame, text="Entity Type:").pack(side="left")
        
        type_var = tk.StringVar()
        type_combo = ttk.Combobox(top_frame, textvariable=type_var, values=sorted_types, state="readonly")
        type_combo.pack(side="left", fill="x", expand=True, padx=5)

        # --- Treeview for displaying entities ---
        tree_frame = tk.Frame(self.catalog_win)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=(0, 5))

        catalog_tree = ttk.Treeview(tree_frame, columns=("name", "description"), show="headings")
        catalog_tree.heading("name", text="Name")
        catalog_tree.heading("description", text="Description")
        catalog_tree.column("name", width=250)
        catalog_tree.column("description", width=450)
        
        catalog_tree.pack(side="left", fill="both", expand=True)
        
        tree_scroll = ttk.Scrollbar(tree_frame, orient="vertical", command=catalog_tree.yview)
        tree_scroll.pack(side="right", fill="y")
        catalog_tree.config(yscrollcommand=tree_scroll.set)

        # --- Editing Frame ---
        edit_frame = tk.LabelFrame(self.catalog_win, text="Edit Selected Entity", padx=10, pady=10)
        edit_frame.pack(fill="x", padx=10, pady=5)

        tk.Label(edit_frame, text="Name:").grid(row=0, column=0, sticky="w", pady=2)
        name_edit_var = tk.StringVar()
        name_edit_entry = tk.Entry(edit_frame, textvariable=name_edit_var)
        name_edit_entry.grid(row=0, column=1, sticky="ew", padx=5)

        tk.Label(edit_frame, text="Description:").grid(row=1, column=0, sticky="nw", pady=2)
        desc_edit_text = tk.Text(edit_frame, height=4, wrap="word")
        desc_edit_text.grid(row=1, column=1, sticky="ew", padx=5)
        edit_frame.grid_columnconfigure(1, weight=1)

        # --- Button Frame within Edit Frame ---
        button_frame = tk.Frame(edit_frame)
        button_frame.grid(row=2, column=1, sticky="e", pady=5)

        copy_button = tk.Button(button_frame, text="Copy Selected", state="disabled")
        copy_button.pack(side="left", padx=(0, 10))

        update_button = tk.Button(button_frame, text="Update Entity", state="disabled")
        update_button.pack(side="left")
        
        default_button_bg = update_button.cget("background") # Store default color

        # --- Logic ---
        def copy_selection_to_clipboard(*args):
            """Copies the selected rows from the catalog tree to the clipboard."""
            selection = catalog_tree.selection()
            if not selection:
                return

            data_to_copy = []
            for item_id in selection:
                values = catalog_tree.item(item_id, "values")
                # Join columns with a tab for easy pasting into spreadsheets/text editors
                row_string = "\t".join(str(v) for v in values)
                data_to_copy.append(row_string)

            final_string = "\n".join(data_to_copy)

            if final_string:
                self.catalog_win.clipboard_clear()
                self.catalog_win.clipboard_append(final_string)
                copy_button.config(background=default_button_bg) # Reset glow

        def on_type_selected(*args):
            selected_type = type_var.get()
            catalog_tree.delete(*catalog_tree.get_children()) # Clear previous entries
            if not selected_type:
                return

            for el in self.model.findall(".//element"):
                el_type_full = el.get(f"{{{XSI}}}type", "")
                if el_type_full.replace("archimate:", "") == selected_type:
                    el_id = el.get("id")
                    name = el.get("name", "")
                    doc_el = el.find("documentation")
                    description = doc_el.text if doc_el is not None else ""
                    catalog_tree.insert("", "end", iid=el_id, values=(name, description))

        def on_catalog_item_select(*args):
            selection = catalog_tree.selection()
            if not selection:
                name_edit_var.set("")
                desc_edit_text.delete("1.0", "end")
                update_button.config(state="disabled")
                copy_button.config(state="disabled", background=default_button_bg) # Disable and reset glow
                return
            
            item_id = selection[0]
            values = catalog_tree.item(item_id, "values")
            name_edit_var.set(values[0])
            desc_edit_text.delete("1.0", "end")
            desc_edit_text.insert("1.0", values[1])
            update_button.config(state="normal")
            copy_button.config(state="normal", background="yellow") # Enable and set glow

        def update_entity():
            selection = catalog_tree.selection()
            if not selection:
                return
            
            item_id = selection[0]
            element_to_update = self.find_element_by_id(item_id)
            if element_to_update is None:
                messagebox.showerror("Error", "Could not find the selected element in the model.")
                return

            new_name = name_edit_var.get().strip()
            new_desc = desc_edit_text.get("1.0", "end-1c").strip()

            if not new_name:
                messagebox.showwarning("Validation", "Element name cannot be empty.")
                return

            # Update the XML model
            element_to_update.set("name", new_name)
            
            doc_el = element_to_update.find("documentation")
            if new_desc:
                if doc_el is None:
                    doc_el = ET.SubElement(element_to_update, "documentation")
                doc_el.text = new_desc
            elif doc_el is not None:
                # Remove documentation element if description is cleared
                element_to_update.remove(doc_el)

            # Update the catalog tree view
            catalog_tree.item(item_id, values=(new_name, new_desc))

            # Mark model as dirty and refresh main UI
            self.dirty = True
            self.save_history()
            self.build_element_database()
            self.build_relationship_map()
            self.calculate_relationship_counts()
            self.refresh_tree()
            self.update_xml_output_panel()
            self.update_button_states()
            messagebox.showinfo("Success", f"Updated '{new_name}'.")

        type_var.trace_add('write', on_type_selected)
        catalog_tree.bind("<<TreeviewSelect>>", on_catalog_item_select)
        update_button.config(command=update_entity)
        copy_button.config(command=copy_selection_to_clipboard)

    # --- Gemini Context Management ---

    def extract_model_inventory(self):
        """Builds a compact entity inventory."""
        if self.model is None:
            return []
        inventory = []
        for el in self.model.findall(".//element"):
            etype = el.get(f"{{{XSI}}}type", "").replace("archimate:", "")
            name = el.get("name", "")
            if name:
                inventory.append(f"{etype} | {name}")
        return inventory

    def extract_model_triples(self):
        """Builds compact triples of relationships."""
        if self.model is None:
            return []
        triples = []
        for rel in self.find_all_relationships():
            rel_type = rel.get(f"{{{XSI}}}type", "").replace("archimate:", "")
            src = self.element_db_by_id.get(rel.get("source"), {}).get("name", "")
            tgt = self.element_db_by_id.get(rel.get("target"), {}).get("name", "")
            if src and tgt:
                triples.append(f"{src} -> {rel_type} -> {tgt}")
        return triples

    def handle_ask_gemini(self):
        """Handles the Ask Gemini button press from the main GUI panel."""
        prompt = self.gemini_prompt_text.get("1.0", "end").strip()
        if not prompt or "e.g.," in prompt:
            messagebox.showwarning("Gemini", "Please enter a valid prompt.")
            return
        
        self._send_to_gemini(prompt)

    def build_gemini_context(self, delta_only=False):
        """Builds the context payload (inventory + triples, or delta)."""
        if delta_only and hasattr(self, "_last_snapshot"):
            # Compute delta
            current_inv = set(self.extract_model_inventory())
            current_triples = set(self.extract_model_triples())
            old_inv, old_triples = self._last_snapshot
            new_inv = current_inv - old_inv
            new_triples = current_triples - old_triples
            context = ["# Delta Model Update"]
            if new_inv:
                context.append("Entities:\n" + "\n".join(sorted(new_inv)))
            if new_triples:
                context.append("Relationships:\n" + "\n".join(sorted(new_triples)))
        else:
            # Full snapshot
            inv = self.extract_model_inventory()
            triples = self.extract_model_triples()
            context = ["# Full Model Inventory"]
            context.append("Entities:\n" + "\n".join(sorted(inv)))
            context.append("Relationships:\n" + "\n".join(sorted(triples)))
            # Store snapshot
            self._last_snapshot = (set(inv), set(triples))
        return "\n\n".join(context)

    def _build_auto_context(self, prompt):
        """Builds a targeted context by finding elements mentioned in the prompt."""
        prompt_lower = prompt.lower()
        mentioned_ids = set()
        
        # Find all elements whose names appear in the prompt
        for name_lower, elements in self.element_db.items():
            if name_lower in prompt_lower:
                for el_id, _ in elements:
                    mentioned_ids.add(el_id)
        
        if not mentioned_ids:
            return "# No relevant context detected in the model."

        # Build the context from the found elements and their direct relationships
        entities = set()
        relationships = set()
        
        for el_id in mentioned_ids:
            el_data = self.element_db_by_id.get(el_id)
            if not el_data: continue
            
            el_type_short = el_data['type'].split(':')[-1]
            entities.add(f"{el_type_short} | {el_data['name']}")
            
            # Add all relationships connected to this element
            for rel in self.get_element_relationships(el_id):
                source_data = self.element_db_by_id.get(el_id)
                target_data = self.element_db_by_id.get(rel['id'])
                if not source_data or not target_data: continue

                if rel['direction'] == 'out':
                    relationships.add(f"{source_data['name']} -> {rel['type']} -> {target_data['name']}")
                else: # 'in'
                    relationships.add(f"{target_data['name']} -> {rel['type']} -> {source_data['name']}")

        context = ["# Auto-Detected Model Context"]
        if entities:
            context.append("Entities:\n" + "\n".join(sorted(list(entities))))
        if relationships:
            context.append("Relationships:\n" + "\n".join(sorted(list(relationships))))
            
        return "\n\n".join(context)


    def _send_to_gemini(self, prompt):
        """Sends a prompt to the Gemini API and adds the response to the paste area."""
        if not GEMINI_API_KEY or GEMINI_API_KEY == "YOUR_API_KEY":
            messagebox.showerror("Gemini API Error", "Please set your GEMINI_API_KEY at the top of the script.")
            return

        self.gemini_generate_button.config(text="Thinking...", state="disabled")
        self.status_var.set("Asking Gemini...")
        self.root.update_idletasks()  # Force UI update

        try:
            genai.configure(api_key=GEMINI_API_KEY)
            selected_model = self.model_var.get().strip() or "models/gemini-2.5-pro"
            model = genai.GenerativeModel(selected_model)

            # --- Build Authoritative Lists ---
            all_element_types = sorted(list(FOLDER_MAP.keys()))
            all_relationship_types = sorted(list(RELATIONSHIP_TYPES))

            # --- Build Context based on selected strategy ---
            strategy = self.gemini_context_strategy_var.get()
            context = ""
            if strategy == "Full Model":
                context = self.build_gemini_context()
            elif strategy == "Auto-Detect":
                context = self._build_auto_context(prompt)
            else: # "None (Stateless)"
                context = "# No model context was provided."


            # --- New, Re-structured System Prompt ---
            system_prompt = f"""
# Persona
You are an expert Enterprise Architect and a master of the ArchiMate modeling language. Your purpose is to act as a creative modeling partner who communicates solutions exclusively in a structured text format.

# Core Task
Analyze the user's request and the provided model context. Design a concise and logical architectural model that fulfills the request. Then, represent your entire solution as a list of new elements and relationships using the strict format defined below.

# Output Format
- Elements: `ElementType | ElementName | description=...`
- Relationships: `RelationshipType | SourceElementName | source_type=SourceElementType | target=TargetElementName | target_type=TargetElementType | description=...`

## Example:
`BusinessActor | Planning Officer | description=A role responsible for urban and regional planning.`
`Goal | Improve Permit Processing Time | description=Reduce the average time to approve new building permits.`
`InfluenceRelationship | Planning Officer | source_type=BusinessActor | target=Improve Permit Processing Time | target_type=Goal | description=The officer's work directly impacts permit efficiency.`

# Authoritative Lists
- You MUST use element types from this complete list: {', '.join(all_element_types)}
- You MUST use relationship types from this complete list: {', '.join(all_relationship_types)}

# Critical Rules
1.  **GENERATE CONTENT (MOST IMPORTANT RULE)**: Your primary value is generating meaningful content. Create specific, descriptive names for elements (e.g., "Online Permit Application Portal" instead of just "Application"). You MUST provide a concise `description` for every new element and relationship that explains its purpose and context.
2.  **STRICT FORMATTING**: Adhere strictly to the output format. Do not add explanations, apologies, or any text outside of the defined format. Do not use markdown.
3.  **RESOLVE AMBIGUITY**: When creating a relationship, you MUST include both `source_type` and `target_type` attributes. This is essential for creating correct links in a model where different elements might share the same name.
4.  **USE AUTHORITATIVE LISTS**: Only use types from the lists provided above. If a user asks for a type not on a list, select the closest valid equivalent.
5.  **LEVERAGE CONTEXT**: The provided model context is your source of truth. Before creating a new element, check if an element with the **same name AND type** already exists. If it does, reference it. If the user's request implies a new, distinct element, create it with a specific name that differentiates it.
6.  **EXACT NAMING**: The `SourceElementName` and `TargetElementName` in a relationship must exactly match the names of the elements you are linking.
"""

            # The user request and context are now added outside the main system prompt for clarity
            full_prompt = [
                system_prompt,
                "# Model Context",
                context,
                "# User's Request",
                f'"{prompt}"'
            ]

            response = model.generate_content("\n".join(full_prompt))
            response_text = response.text.strip()

            if not response_text:
                messagebox.showinfo("Gemini", "Received an empty response.")
                return

            current_paste_content = self.paste_text.get("1.0", "end").strip()
            if current_paste_content:
                self.paste_text.insert("end", f"\n# --- Gemini Response for: \"{prompt}\" ---\n" + response_text)
            else:
                self.paste_text.insert("end", response_text)
            
            self.update_staged_preview()
            messagebox.showinfo("Gemini", "Response added to Paste Area.")

        except Exception as e:
            messagebox.showerror("Gemini API Error", f"An error occurred: {e}")
        finally:
            self.gemini_generate_button.config(text="Generate!", state="normal")
            self.status_var.set("Ready.")

    # --- Autocomplete Feature ---

    def _create_progress_window(self, title, max_value):
        """Creates and displays a standardized progress bar window."""
        progress_win = tk.Toplevel(self.root)
        progress_win.title(title)
        progress_win.geometry("450x120")
        progress_win.transient(self.root)
        progress_win.grab_set()
        progress_win.resizable(False, False)

        tk.Label(progress_win, text=f"Processing: {title}...", font=("Segoe UI", 10)).pack(pady=(10, 5))
        
        progress_bar = ttk.Progressbar(progress_win, orient="horizontal", length=400, mode="determinate", maximum=max_value)
        progress_bar.pack(pady=5)
        
        status_label = tk.Label(progress_win, text="Initializing...")
        status_label.pack(pady=5)

        return progress_win, progress_bar, status_label

    def autocomplete_model_conservative(self):
        """
        Scans the model and adds missing ArchiMate entities and relationships based on a configurable set of conservative rules.
        """
        if self.model is None:
            messagebox.showwarning("No model", "Open an .archimate file first.")
            return

        self.save_history()
        added_elements_log = []
        added_relationships_log = []

        # Build a comprehensive list of all elements
        elements_by_type = {}
        all_elements_by_id = {}
        for folder in self.model.findall("folder"):
            for el in folder.findall("element"):
                el_id = el.get("id")
                el_name = el.get("name", "")
                el_type_full = el.get(f"{{{XSI}}}type", "")
                el_type = el_type_full.replace("archimate:", "")
                if el_id and el_name and el_type:
                    if el_type not in elements_by_type:
                        elements_by_type[el_type] = []
                    element_data = {'id': el_id, 'type': el_type, 'name': el_name, 'el': el}
                    elements_by_type[el_type].append(element_data)
                    all_elements_by_id[el_id] = element_data

        # --- Progress Bar Setup ---
        total_iterations = 0
        for rule in AUTOCOMPLETE_RULES:
            source_elements = []
            for el_type in rule['source_types']:
                source_elements.extend(elements_by_type.get(el_type, []))
            target_elements = []
            for el_type in rule['target_types']:
                target_elements.extend(elements_by_type.get(el_type, []))
            total_iterations += len(source_elements) * len(target_elements)

        if total_iterations == 0:
            messagebox.showinfo("Autocomplete", "No element pairs to check.")
            return

        progress_win, progress_bar, status_label = self._create_progress_window("Autocomplete", total_iterations)
        current_iteration = 0

        try:
            # --- Rule Processing Engine ---
            for rule in AUTOCOMPLETE_RULES:
                source_elements = []
                for el_type in rule['source_types']:
                    source_elements.extend(elements_by_type.get(el_type, []))

                target_elements = []
                for el_type in rule['target_types']:
                    target_elements.extend(elements_by_type.get(el_type, []))

                for source_data in source_elements:
                    for target_data in target_elements:
                        current_iteration += 1
                        if current_iteration % 100 == 0:  # Update UI periodically to avoid slowdown
                            progress_bar['value'] = current_iteration
                            status_label.config(text=f"Rule: {rule['name'][:40]}...")
                            self.root.update_idletasks()

                        if self._evaluate_autocomplete_conditions(rule['conditions'], source_data, target_data):
                            new_els, new_rels = self._execute_autocomplete_action(rule, source_data, target_data, all_elements_by_id)
                            added_elements_log.extend(new_els)
                            added_relationships_log.extend(new_rels)
        finally:
            progress_win.destroy()

        # Update the element database and refresh
        self.build_element_database()
        self.build_relationship_map()
        self.calculate_relationship_counts()
        self.refresh_tree()
        self.update_xml_output_panel()

        if added_elements_log or added_relationships_log:
            self.dirty = True
        self.update_button_states()

        # Show results
        result_msg = "Autocomplete completed based on configurable rules.\n"
        if added_elements_log:
            result_msg += f"Added {len(added_elements_log)} elements:\n- " + "\n- ".join(added_elements_log) + "\n\n"
        if added_relationships_log:
            result_msg += f"Added {len(added_relationships_log)} relationships:\n- " + "\n- ".join(added_relationships_log)

        if not added_elements_log and not added_relationships_log:
            result_msg = "No missing elements or relationships found based on the current rules."

        self._show_report_window("Autocomplete Report", result_msg)

    def _execute_autocomplete_action(self, rule, source_data, target_data, all_elements_by_id):
        """Executes the 'action' part of an autocomplete rule, creating elements and relationships."""
        added_elements = []
        added_relationships = []
        
        action = rule['action']
        
        # --- Create Intermediate Element if specified ---
        new_element_id = None
        if 'create_element' in action:
            new_element_type = action['create_element']['type']
            # Use a format string for the name, substituting source/target names
            name_template = action['create_element']['name']
            new_element_name = name_template.format(source=source_data['name'], target=target_data['name'])

            # Corrected duplicate check: Only skip if name AND type match
            is_duplicate = False
            # The DB now returns a list of potential matches
            potential_matches = self.element_db.get(new_element_name.lower(), [])
            existing_info = None
            for match in potential_matches:
                _, existing_type_full = match
                if existing_type_full.split(":")[-1] == new_element_type:
                    is_duplicate = True
                    existing_info = match # Store the correct existing element
                    break
            
            if not is_duplicate:
                folder = self.get_folder_for_type(new_element_type)
                if folder is not None:
                    new_element_id = generate_id()
                    attribs = {f"{{{XSI}}}type": f"archimate:{new_element_type}", "name": new_element_name, "id": new_element_id}
                    new_el = ET.SubElement(folder, "element", attribs)
                    
                    # Update databases immediately
                    self.element_db[new_element_name] = (new_element_id, f"archimate:{new_element_type}")
                    self.element_db[new_element_name.lower()] = (new_element_id, f"archimate:{new_element_type}")
                    all_elements_by_id[new_element_id] = {'id': new_element_id, 'type': new_element_type, 'name': new_element_name, 'el': new_el}
                    added_elements.append(f"{new_element_type}: {new_element_name}")
            else:
                # If it's a duplicate, we still need its ID for relationship creation
                new_element_id = existing_info[0] if existing_info else None

        # --- Create Relationships ---
        rel_folder = self.get_or_create_relations_folder()
        for rel_action in action.get('create_relationships', []):
            rel_type = rel_action['type']
            
            # Determine source and target based on the rule
            source_id = source_data['id'] if rel_action['source'] == 'source' else (new_element_id if new_element_id else target_data['id'])
            target_id = target_data['id'] if rel_action['target'] == 'target' else (new_element_id if new_element_id else source_data['id'])

            # Check if this exact relationship already exists
            if not self._relationship_exists(source_id, target_id, rel_type):
                rel_id = generate_id()
                rel_attribs = {
                    f"{{{XSI}}}type": f"archimate:{rel_type}",
                    "id": rel_id, "source": source_id, "target": target_id
                }
                ET.SubElement(rel_folder, "element", rel_attribs)
                
                source_name = all_elements_by_id.get(source_id, {}).get('name', 'Unknown')
                target_name = all_elements_by_id.get(target_id, {}).get('name', 'Unknown')
                added_relationships.append(f"{source_name} -> {rel_type} -> {target_name}")

        return added_elements, added_relationships

    def _relationship_exists(self, source_id, target_id, rel_type):
        """Checks if a specific relationship already exists in the model."""
        rel_type_full = f"archimate:{rel_type}"
        for rel in self.find_all_relationships():
            if (rel.get("source") == source_id and
                rel.get("target") == target_id and
                rel.get(f"{{{XSI}}}type") == rel_type_full):
                return True
        return False


    def _evaluate_autocomplete_conditions(self, conditions, source_data, target_data):
        """Evaluates if the conditions for an autocomplete rule are met."""
        for condition in conditions:
            if condition['type'] == 'no_relationship_of_type':
                rel_types_to_check = condition['rel_types']
                # Check for direct relationship
                for rel in self.get_element_relationships(source_data['id']):
                    if rel['id'] == target_data['id'] and rel['type'] in rel_types_to_check:
                        return False  # Found a disallowed relationship, condition fails
                # Check for reverse relationship
                for rel in self.get_element_relationships(target_data['id']):
                    if rel['id'] == source_data['id'] and rel['type'] in rel_types_to_check:
                        return False  # Found a disallowed relationship, condition fails
            
            elif condition['type'] == 'name_similarity':
                # Simple name similarity check (you can implement more sophisticated logic)
                source_name = source_data['name'].lower()
                target_name = target_data['name'].lower()
                threshold = condition.get('threshold', 0.5)
                
                # Simple word overlap check
                source_words = set(source_name.split())
                target_words = set(target_name.split())
                overlap = len(source_words & target_words) / max(len(source_words), len(target_words))
                if overlap < threshold:
                    return False           
            elif condition['type'] == 'target_name_is_part_of_source':
                source_name = source_data['name'].lower()
                target_name = target_data['name'].lower()
                threshold = condition.get('threshold', 0.8)
                
                # Check if target name appears within source name
                if target_name not in source_name:
                    return False
        
        return True  # All conditions passed


    # Add a more conservative validation function
    def validate_relationships_conservative(self):
        """
        Conservative validation that focuses on the most problematic relationship types.
        """
        if self.model is None:
            messagebox.showwarning("No model", "Open an .archimate file first.")
            return
    
        # Focus on the most common illegal relationships
        common_illegal_patterns = [
            # Requirement -> BusinessService: Realization is illegal
            ("Requirement", "BusinessService", "RealizationRelationship"),
            # BusinessService -> ApplicationComponent: RealizationRelationship is questionable
            ("BusinessService", "ApplicationComponent", "RealizationRelationship"),
            # ApplicationComponent -> BusinessActor: Serving is questionable
            ("ApplicationComponent", "BusinessActor", "ServingRelationship"),
        ]
    
        illegal_relationships = []
    
        for folder in self.model.findall("folder"):
            for rel in folder.findall("element"):
                rel_type = rel.get(f"{{{XSI}}}type", "")
                if not rel_type.endswith("Relationship"):
                    continue
                 
                source_id = rel.get("source")
                target_id = rel.get("target")
            
                source_el = self.find_element_by_id(source_id)
                target_el = self.find_element_by_id(target_id)
            
                if source_el is None or target_el is None:
                    continue
                 
                source_type = source_el.get(f"{{{XSI}}}type", "").replace("archimate:", "")
                target_type = target_el.get(f"{{{XSI}}}type", "").replace("archimate:", "")
            
                # Check against common illegal patterns
                for illegal_pattern in common_illegal_patterns:
                    if (source_type == illegal_pattern[0] and 
                        target_type == illegal_pattern[1] and 
                        rel_type.endswith(illegal_pattern[2])):
                    
                        source_name = source_el.get("name", "Unnamed")
                        target_name = target_el.get("name", "Unnamed")
                        illegal_relationships.append({
                            "relationship": rel_type,
                            "source": f"{source_type}: {source_name}",
                            "target": f"{target_type}: {target_name}",
                            "pattern": f"{illegal_pattern[0]} -> {illegal_pattern[1]} with {illegal_pattern[2]}"
                        })
                        break
    
        if not illegal_relationships:
            messagebox.showinfo("Validation", "No problematic relationships found!")
            return
    
        # Build the report string
        report_content = f"Found {len(illegal_relationships)} potentially problematic relationships:\n\n"
        for i, rel in enumerate(illegal_relationships, 1):
            report_content += f"{i}. {rel['pattern']}\n"
            report_content += f"   Source: {rel['source']}\n"
            report_content += f"   Target: {rel['target']}\n\n"
            
        self._show_report_window("Problematic Relationships Report", report_content)
    
     
    
    def is_relationship_allowed(self, source_type, target_type, relationship_type):
        """
        Check if a relationship is allowed between two element types according to ArchiMate spec.
        """
        # Remove namespace prefix if present
        if ":" in source_type:
            source_type = source_type.split(":")[-1]
        if ":" in target_type:
            target_type = target_type.split(":")[-1]
        if ":" in relationship_type:
            relationship_type = relationship_type.split(":")[-1]
    
        # Get rules for source type, fall to back to default rules
        rules = RELATIONSHIP_RULES.get(source_type, RELATIONSHIP_RULES["*"])
    
        # Check if this relationship type is allowed for the source
        if relationship_type not in rules["allowed_targets"]:
            return False
    
        # Check if the target type is allowed for this relationship
        allowed_targets = rules["allowed_targets"][relationship_type]
        if "*" in allowed_targets:
            return True
        return target_type in allowed_targets

    def validate_all_relationships(self):
        """
        Scan all relationships in the model and identify illegal ones.
        """
        illegal_relationships = []
    
        for folder in self.model.findall("folder"):
            for rel in folder.findall("element"):
                rel_type = rel.get(f"{{{XSI}}}type", "")
                if not rel_type.endswith("Relationship"):
                    continue
                 
                source_id = rel.get("source")
                target_id = rel.get("target")
            
                source_el = self.find_element_by_id(source_id)
                target_el = self.find_element_by_id(target_id)
            
                if source_el is None or target_el is None:
                    continue
                 
                source_type = source_el.get(f"{{{XSI}}}type", "")
                target_type = target_el.get(f"{{{XSI}}}type", "")
            
                if not self.is_relationship_allowed(source_type, target_type, rel_type):
                    source_name = source_el.get("name", "Unnamed")
                    target_name = target_el.get("name", "Unnamed")
                    illegal_relationships.append({
                        "relationship": rel_type,
                        "source": f"{source_type}: {source_name}",
                        "target": f"{target_type}: {target_name}"
                    })
    
        return illegal_relationships
    def fix_and_refresh(self, window):
        """
        Fix illegal relationships and refresh the report window.
        """
        fixed_count, illegal_count = self.fix_illegal_relationships()
        self.refresh_tree()
        self.update_xml_output_panel()
    
        messagebox.showinfo("Fix Complete", 
                           f"Fixed {fixed_count} of {illegal_count} illegal relationships.")
        window.destroy()
    def fix_illegal_relationships(self):
        """
        Attempt to fix illegal relationships by replacing them with legal alternatives.
        """
        illegal_relationships = self.validate_all_relationships()
        fixed_count = 0
    
        for illegal_rel in illegal_relationships:
            rel_type = illegal_rel["relationship"]
            source_type = illegal_rel["source"].split(":")[0].strip()
            target_type = illegal_rel["target"].split(":")[0].strip()
        
            # Find the relationship element to fix
            for folder in self.model.findall("folder"):
                for rel in folder.findall("element"):
                    if rel.get(f"{{{XSI}}}type", "") == rel_type:
                        source_id = rel.get("source")
                        target_id = rel.get("target")
                    
                        source_el = self.find_element_by_id(source_id)
                        target_el = self.find_element_by_id(target_id)
                    
                        if (source_el and source_el.get("name", "") in illegal_rel["source"] and
                            target_el and target_el.get("name", "") in illegal_rel["target"]):
                        
                            # Try to find a legal alternative relationship type
                            alternative_rel = self.find_legal_alternative(source_type, target_type, rel_type)
                        
                            if alternative_rel:
                                # Replace the relationship type
                                rel.set(f"{{{XSI}}}type", f"archimate:{alternative_rel}")
                                fixed_count += 1
                            else:
                                # No legal alternative found, remove the relationship
                                folder.remove(rel)
                                fixed_count += 1
    
        return fixed_count, len(illegal_relationships)

    def find_legal_alternative(self, source_type, target_type, original_rel_type):
        """
        Find a legal alternative relationship type for the given source and target types.
        """
        # Common illegal relationship fixes
        relationship_fixes = {
            # Requirement -> BusinessService: RealizationRelationship is illegal
            ("Requirement", "BusinessService", "RealizationRelationship"): "InfluenceRelationship",
            # BusinessService -> ApplicationService: RealizationRelationship is legal, but sometimes mistaken
            ("BusinessService", "ApplicationService", "RealizationRelationship"): "ServingRelationship",
            # ApplicationService -> TechnologyService: RealizationRelationship is legal, but sometimes mistaken
            ("ApplicationService", "TechnologyService", "RealizationRelationship"): "ServingRelationship",
        }
    
        # Check for specific fixes
        key = (source_type, target_type, original_rel_type)
        if key in relationship_fixes:
            return relationship_fixes[key]
    
        # Generic fallback: try to find any legal relationship
        rules = RELATIONSHIP_RULES.get(source_type, RELATIONSHIP_RULES["*"])
        for rel_type, allowed_targets in rules["allowed_targets"].items():
            if "*" in allowed_targets or target_type in allowed_targets:
                return rel_type
    
        return None    
    RELATIONSHIP_FIX_PRIORITY = [
        "AssociationRelationship", "InfluenceRelationship", "ServingRelationship", 
        "UsedByRelationship", "AccessRelationship", "FlowRelationship", 
        "TriggeringRelationship", "RealizationRelationship", "AssignmentRelationship", 
        "SpecializationRelationship", "CompositionRelationship", "AggregationRelationship"
    ]

    def _find_alternative_relationship(self, source_type, target_type):
        """Finds all valid relationship types from a source type to a target type."""
        valid_rels = []
        source_type_short = source_type.split(":")[-1]
        target_type_short = target_type.split(":")[-1]

        source_rules = RELATIONSHIP_RULES.get(source_type_short, {})
        for rel_type, allowed_targets in source_rules.get("allowed_targets", {}).items():
            if "*" in allowed_targets or target_type_short in allowed_targets:
                valid_rels.append(rel_type)

        default_rules = RELATIONSHIP_RULES.get("*", {})
        for rel_type, allowed_targets in default_rules.get("allowed_targets", {}).items():
            if rel_type not in valid_rels and ("*" in allowed_targets or target_type_short in allowed_targets):
                valid_rels.append(rel_type)
        
        return valid_rels

    def _attempt_to_fix_relationship(self, rel):
        """Tries to fix an illegal relationship by changing its type or direction."""
        source_el = self.find_element_by_id(rel.get("source"))
        target_el = self.find_element_by_id(rel.get("target"))
        
        if source_el is None or target_el is None:
            return None

        source_type = source_el.get(f"{{{XSI}}}type")
        target_type = target_el.get(f"{{{XSI}}}type")
        original_rel_type = rel.get(f"{{{XSI}}}type")
        
        source_name = source_el.get("name", "Unnamed")
        target_name = target_el.get("name", "Unnamed")
        original_rel_type_short = original_rel_type.split(':')[-1]

        # Attempt 1: Change direction (if current type is valid in reverse)
        if self.is_relationship_allowed(target_type, source_type, original_rel_type):
            rel.set("source", target_el.get("id"))
            rel.set("target", source_el.get("id"))
            return f"Reversed direction of {original_rel_type_short} between '{target_name}' and '{source_name}'."

        # Attempt 2: Find alternative relationship type (same direction)
        valid_rels_same_dir = self._find_alternative_relationship(source_type, target_type)
        if valid_rels_same_dir:
            for best_rel in self.RELATIONSHIP_FIX_PRIORITY:
                if best_rel in valid_rels_same_dir:
                    rel.set(f"{{{XSI}}}type", f"archimate:{best_rel}")
                    
                    return f"Changed type from {original_rel_type_short} to {best_rel} for '{source_name}' -> '{target_name}'."


        # Attempt 3: Find alternative relationship type (reversed direction)
        valid_rels_rev_dir = self._find_alternative_relationship(target_type, source_type)
        if valid_rels_rev_dir:
            for best_rel in self.RELATIONSHIP_FIX_PRIORITY:
                if best_rel in valid_rels_rev_dir:
                    rel.set("source", target_el.get("id"))
                    rel.set("target", source_el.get("id"))
                    rel.set(f"{{{XSI}}}type", f"archimate:{best_rel}")
                    return f"Reversed and changed type from {original_rel_type_short} to {best_rel} for '{target_name}' -> '{source_name}'."

        return None # No fix found

    def find_all_relationships(self):
        """
        Finds and returns a list of all relationship elements in the model.
        """
        if self.model is None:
            return []
        relationships = []
        for folder in self.model.findall("folder"):
            for element in folder.findall("element"):
                if element.get(f"{{{XSI}}}type", "").endswith("Relationship"):
                    relationships.append(element)
        return relationships

    def validate_and_clean_relationships(self):
        """
        Performs a full validation and cleaning of the model.
        1. Relocates misplaced elements to their correct folders.
        2. Removes orphaned relationships (invalid source/target).
        3. Removes duplicate relationships.
        4. Attempts to fix illegal relationships by changing type or direction.
        5. Removes relationships that cannot be fixed.
        6. Provides a detailed report of all actions taken.
        """
        if self.model is None:
            messagebox.showwarning("No model", "Open an .archimate file first.")
            return

        self.save_history()
        relocated_log = []
        orphans_removed_log = []
        duplicates_removed_log = []
        fixed_rels_log = []
        unfixable_rels_log = []

        # --- Progress Bar Setup ---
        all_relationships = self.find_all_relationships()
        all_elements = self.model.findall(".//element")
        total_steps = len(all_elements) + (len(all_relationships) * 3) # Relocate + 3 checks per relationship
        
        progress_win, progress_bar, status_label = self._create_progress_window("Clean & Validate", total_steps)
        current_step = 0

        try:
            # --- Step 1: Relocate Misplaced Elements ---
            status_label.config(text="Relocating misplaced elements...")
            self.root.update_idletasks()
            
            all_folders = {f.get("name"): f for f in self.model.findall("folder")}
            elements_to_move = []

            for element in all_elements:
                current_step += 1
                progress_bar['value'] = current_step

                el_type_full = element.get(f"{{{XSI}}}type", "")
                if not el_type_full: continue

                parent_folder = next((p for p in self.model.findall('folder') if element in p), None)
                if parent_folder is None: continue # Should not happen in a valid model

                # If it's a relationship, ensure it's in the 'Relations' folder
                if "Relationship" in el_type_full:
                    relations_folder = self.get_or_create_relations_folder()
                    if parent_folder is not relations_folder:
                        elements_to_move.append((element, parent_folder, "Relations"))
                    continue

                # If it's a standard element, check its folder
                correct_folder_name = FOLDER_MAP.get(el_type_full.replace("archimate:", ""))
                if not correct_folder_name: continue # Skip elements not in FOLDER_MAP (e.g., diagram objects)

                if parent_folder.get("name") != correct_folder_name:
                    elements_to_move.append((element, parent_folder, correct_folder_name))

            for element, source_folder, correct_folder_name in elements_to_move:
                target_folder = all_folders.get(correct_folder_name)
                if target_folder is None:
                    # Create the folder if it doesn't exist
                    folder_type_from_map = correct_folder_name.lower().replace(" & ", "_")
                    target_folder = ET.SubElement(self.model, "folder", {
                        "name": correct_folder_name, "id": generate_id(), "type": folder_type_from_map
                    })
                    all_folders[correct_folder_name] = target_folder
                    relocated_log.append(f"Created missing folder: '{correct_folder_name}'")

                source_folder.remove(element)
                target_folder.append(element)
                relocated_log.append(f"Relocated '{element.get('name')}' from '{source_folder.get('name')}' to '{correct_folder_name}'.")

            # --- Step 2: Remove Orphans ---
            status_label.config(text="Checking for orphaned relationships...")
            self.root.update_idletasks()
            valid_ids = {element.get("id") for element in self.model.findall(".//element")}
            
            all_relationships = self.find_all_relationships() # Re-fetch after potential moves
            rels_to_process = []
            for rel in all_relationships:
                current_step += 1
                progress_bar['value'] = current_step
                source_id = rel.get("source")
                target_id = rel.get("target")
                if source_id not in valid_ids or target_id not in valid_ids:
                    source_name = self.element_db_by_id.get(source_id, {}).get('name', f'ID: {source_id}')
                    target_name = self.element_db_by_id.get(target_id, {}).get('name', f'ID: {target_id}')
                    rel_type_short = rel.get(f"{{{XSI}}}type", "Rel").split(':')[-1]
                    orphans_removed_log.append(f"Removed orphaned '{rel_type_short}' from '{source_name}' to '{target_name}'")
                    self._find_and_remove_element(rel)
                else:
                    rels_to_process.append(rel)

            # --- Step 3: Remove Duplicates ---
            status_label.config(text="Checking for duplicate relationships...")
            self.root.update_idletasks()
            unique_relationships = set()
            for rel in list(rels_to_process): # Iterate over a copy
                current_step += 1
                progress_bar['value'] = current_step
                source_id = rel.get("source")
                target_id = rel.get("target")
                rel_type_full = rel.get(f"{{{XSI}}}type", "")
                rel_tuple = (source_id, target_id, rel_type_full)

                if rel_tuple in unique_relationships:
                    source_name = self.find_element_by_id(rel.get("source")).get('name', 'Unnamed')
                    target_name = self.find_element_by_id(rel.get("target")).get('name', 'Unnamed')
                    rel_type_short = rel.get(f"{{{XSI}}}type").split(':')[-1]
                    duplicates_removed_log.append(f"Removed duplicate '{rel_type_short}' from '{source_name}' to '{target_name}'")
                    self._find_and_remove_element(rel)
                    rels_to_process.remove(rel)
                else:
                    unique_relationships.add(rel_tuple)

            # --- Step 4: Fix Illegal Relationships ---
            status_label.config(text="Fixing illegal relationships...")
            self.root.update_idletasks()
            for rel in list(rels_to_process): # Iterate over a copy
                current_step += 1
                progress_bar['value'] = current_step
                source_el = self.find_element_by_id(rel.get("source"))
                target_el = self.find_element_by_id(rel.get("target"))
                
                if not self.is_relationship_allowed(source_el.get(f"{{{XSI}}}type"), target_el.get(f"{{{XSI}}}type"), rel.get(f"{{{XSI}}}type")):
                    fix_desc = self._attempt_to_fix_relationship(rel)
                    if fix_desc:
                        fixed_rels_log.append(fix_desc)
                    else:
                        # Unfixable, remove it
                        source_name = source_el.get("name", "Unnamed")
                        target_name = target_el.get("name", "Unnamed")
                        rel_type_short = rel.get(f"{{{XSI}}}type").split(':')[-1]
                        unfixable_rels_log.append(f"Removed unfixable '{rel_type_short}' from '{source_name}' to '{target_name}'")
                        self._find_and_remove_element(rel)
        finally:
            progress_win.destroy()

        # --- Step 5: Update UI and Report ---
        self.build_element_database()
        self.build_relationship_map()
        self.calculate_relationship_counts()
        self.refresh_tree()
        self.update_xml_output_panel()

        # Build and show report
        report_content = "Validation and Cleaning Report:\n\n"
        report_content += f"--- Summary ---\n"
        report_content += f"Elements relocated: {len(relocated_log)}\n"
        report_content += f"Orphaned relationships removed: {len(orphans_removed_log)}\n"
        report_content += f"Duplicate relationships removed: {len(duplicates_removed_log)}\n"
        report_content += f"Illegal relationships fixed: {len(fixed_rels_log)}\n"
        report_content += f"Unfixable relationships removed: {len(unfixable_rels_log)}\n\n"

        if relocated_log:
            report_content += "--- Relocated Elements ---\n"
            report_content += "\n".join([f"- {log}" for log in relocated_log]) + "\n\n"

        if fixed_rels_log:
            report_content += "--- Fixes Applied ---\n"
            report_content += "\n".join([f"- {log}" for log in fixed_rels_log]) + "\n\n"
        
        if unfixable_rels_log:
            report_content += "--- Unfixable Relationships (Removed) ---\n"
            report_content += "\n".join([f"- {log}" for log in unfixable_rels_log]) + "\n\n"

        if orphans_removed_log:
            report_content += "--- Orphaned Relationships (Removed) ---\n"
            report_content += "\n".join([f"- {log}" for log in orphans_removed_log]) + "\n\n"

        if duplicates_removed_log:
            report_content += "--- Duplicate Relationships (Removed) ---\n"
            report_content += "\n".join([f"- {log}" for log in duplicates_removed_log]) + "\n\n"

        if not any([relocated_log, orphans_removed_log, duplicates_removed_log, fixed_rels_log, unfixable_rels_log]):
            report_content = "Validation Complete: No issues found."
        else:
            self.dirty = True
            self.update_button_states()

        self._show_report_window("Validation Report", report_content)

    def export_pivot_csv(self):
        """Exports the entire model to a single denormalized CSV file for pivot tables."""
        if self.model is None:
            messagebox.showwarning("No Model", "Please load a model before exporting.")
            return

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        default_filename = f"architecture_export_{timestamp}.csv"

        path = filedialog.asksaveasfilename(
            title="Export Architecture to CSV",
            defaultextension=".csv",
            initialfile=default_filename,
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if not path:
            return

        header = [
            "ElementID", "ElementName", "ElementType", "ElementFolder", "ElementDescription",
            "RelatedTo", "RelatedType", "RelatedFolder", "RelationshipType", "RelationshipDescription"
        ]
        
        rows = []
        element_count = 0

        try:
            if self.current_mode == 'db' and self.db_manager:
                # --- Database Mode ---
                db_rows = self.db_manager.get_pivot_data()
                # Clean up element types for readability
                for row in db_rows:
                    row_list = list(row)
                    if row_list[2]: row_list[2] = row_list[2].replace("archimate:", "")
                    if row_list[6]: row_list[6] = row_list[6].replace("archimate:", "")
                    if row_list[8]: row_list[8] = row_list[8].replace("archimate:", "")
                    rows.append(row_list)
                
                # A simple count of unique elements from the first column
                element_count = len(set(r[0] for r in rows))

            else:
                # --- XML File Mode ---
                element_details = {}
                for folder in self.model.findall("folder"):
                    folder_name = folder.get("name", "Unknown")
                    for el in folder.findall(".//element"):
                        el_id = el.get("id")
                        doc_el = el.find("documentation")
                        element_details[el_id] = {
                            "id": el_id,
                            "name": el.get("name", ""),
                            "type": el.get(f"{{{XSI}}}type", "").replace("archimate:", ""),
                            "folder": folder_name,
                            "desc": doc_el.text if doc_el is not None else ""
                        }
                
                element_count = len(element_details)
                related_element_ids = set()

                for rel in self.find_all_relationships():
                    source_id = rel.get("source")
                    target_id = rel.get("target")
                    related_element_ids.add(source_id)
                    related_element_ids.add(target_id)

                    source = element_details.get(source_id)
                    target = element_details.get(target_id)
                    if not source or not target:
                        continue

                    rel_doc = rel.find("documentation")
                    rel_desc = rel_doc.text if rel_doc is not None else ""
                    rel_type = rel.get(f"{{{XSI}}}type", "").replace("archimate:", "")

                    # Row for the source element
                    rows.append([
                        source["id"], source["name"], source["type"], source["folder"], source["desc"],
                        target["name"], target["type"], target["folder"], rel_type, rel_desc
                    ])
                    # Row for the target element
                    rows.append([
                        target["id"], target["name"], target["type"], target["folder"], target["desc"],
                        source["name"], source["type"], source["folder"], rel_type, rel_desc
                    ])

                # Add orphaned elements
                for el_id, details in element_details.items():
                    if el_id not in related_element_ids:
                        rows.append([
                            details["id"], details["name"], details["type"], details["folder"], details["desc"],
                            "", "", "", "", ""
                        ])

            # --- Write to CSV File ---
            with open(path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(header)
                writer.writerows(rows)

            messagebox.showinfo("Export Successful", f"Successfully exported {element_count} elements to:\n{path}")

        except Exception as e:
            messagebox.showerror("Export Error", f"An error occurred during CSV export:\n{e}")


    # --- DB Integration Methods ---
    def open_database(self):
        path = filedialog.askopenfilename(
            title="Open ArchiMate Database",
            filetypes=[("SQLite Database", "*.db;*.sqlite;*.sqlite3"), ("All files", "*.*")]
        )
        if not path:
            return
        try:
            self.db_manager = ArchiMateDB(path)
            self.db_filepath = path
            self.load_model_from_db()
            self.status_var.set(f"Loaded DB: {os.path.basename(path)}")
        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to open database:\n{e}")
            self.db_manager = None
            self.db_filepath = None

    def save_to_database(self):
        if self.model is None:
            messagebox.showwarning("No Model", "No model is currently loaded to save.")
            return

        db_path = self.db_filepath
        if self.current_mode == 'file' or not db_path:
            db_path = filedialog.asksaveasfilename(
                title="Save Model to Database",
                defaultextension=".db",
                filetypes=[("SQLite Database", "*.db"), ("All files", "*.*")]
            )
            if not db_path:
                return

        try:
            if self.db_manager is None or self.db_filepath != db_path:
                self.db_manager = ArchiMateDB(db_path)

            conflicts = self.db_manager.import_from_xml(self.model)

            if conflicts:
                conflict_msg = "Could not save due to version conflicts (model was updated by another user):\n"
                conflict_msg += "\n".join([f"- {c['type']} '{c['name']}'" for c in conflicts[:5]])
                if len(conflicts) > 5:
                    conflict_msg += f"\n... and {len(conflicts) - 5} more."
                messagebox.showwarning("Save Conflict", conflict_msg)
            else:
                self.db_filepath = db_path
                self.current_mode = 'db'
                self.dirty = False
                self.update_button_states()
                self.status_var.set(f"Saved to DB: {os.path.basename(db_path)}")
                messagebox.showinfo("Success", f"Model successfully saved to database:\n{db_path}")

        except Exception as e:
            messagebox.showerror("Database Error", f"Failed to save to database:\n{e}")

    def load_model_from_db(self):
        if not self.db_manager:
            return
        
        self.model = self.db_manager.export_to_xml()
        if self.model is None:
            messagebox.showerror("DB Error", "Failed to construct model from database.")
            return

        self.tree = ET.ElementTree(self.model)
        self.filepath = None # Not a file-based model
        self.current_mode = 'db'
        self.dirty = False
        self.history.clear()
        self.element_db.clear()

        self.build_element_database()
        self.build_relationship_map()
        self.calculate_relationship_counts()
        self.save_history()
        self.refresh_tree()
        self.update_staged_preview()
        self.update_xml_output_panel()
        self.update_button_states()

    # --- File I/O ---
    def open_file(self):
        path = filedialog.askopenfilename(filetypes=[("ArchiMate files", "*.archimate;*.xml"), ("All files","*.*")])
        if not path:
            return
        try:
            self.tree = ET.parse(path)
            self.model = self.tree.getroot()
            self.filepath = path
            self.dirty = False # Freshly loaded file is not dirty
            self.history.clear()
            self.element_db.clear()

            # --- Set mode to file ---
            self.current_mode = 'file'
            self.db_manager = None
            self.db_filepath = None

            self.build_element_database()
            self.build_relationship_map()
            self.calculate_relationship_counts()
            self.save_history()
            self.status_var.set(f"Loaded: {os.path.basename(path)}")
            self.refresh_tree()
            self.update_staged_preview()
            self.update_xml_output_panel()
            self.update_button_states()
        except Exception as e:
            messagebox.showerror("Open error", f"Failed to open file:\n{e}")

    def save_as(self):
        if self.tree is None:
            messagebox.showwarning("No file", "No model loaded.")
            return
        path = filedialog.asksaveasfilename(defaultextension=".archimate", filetypes=[("ArchiMate files", "*.archimate;*.xml")])
        if not path:
            return
        try:
            xml_str = ET.tostring(self.model, encoding='utf-8').decode()
            dom = minidom.parseString(xml_str)
            pretty_xml = dom.toprettyxml(indent="  ")
            lines = pretty_xml.split('\n')
            if lines[0].startswith('<?xml'):
                lines = lines[1:]
            pretty_xml = '\n'.join(lines).strip()
            with open(path, 'w', encoding='utf-8') as f:
                f.write('<?xml version=\'1.0\' encoding=\'utf-8\'?>\n')
                f.write(pretty_xml)
            self.dirty = False # Saved, so no longer dirty
            messagebox.showinfo("Saved", f"Saved to {path}")
            self.status_var.set(f"Saved XML: {os.path.basename(path)}")
            self.update_button_states()
        except Exception as e:
            messagebox.showerror("Save error", f"Failed to save file:\n{e}")

    def build_element_database(self):
        if self.model is None:
            return
        self.element_db.clear()
        self.element_db_by_id = {}
        name_type_combinations = {}
        warnings = []

        for element in self.model.findall(".//element"):
            name = element.get("name")
            element_id = element.get("id")
            element_type = element.get(f"{{{XSI}}}type", "")
            
            if name and element_id:
                name_lower = name.lower()
                # Handle name collisions by storing a list of elements for each name
                if name_lower not in self.element_db:
                    self.element_db[name_lower] = []
                self.element_db[name_lower].append((element_id, element_type))

                # Check for duplicates of different types to warn the user
                if name_lower in name_type_combinations and name_type_combinations[name_lower] != element_type:
                    warnings.append(f"Warning: Name '{name}' is used by multiple element types. Lookups by name may be unpredictable without a type specifier.")
                name_type_combinations[name_lower] = element_type

            if element_id:
                self.element_db_by_id[element_id] = {'name': name, 'type': element_type}
        
        if warnings:
            # Use a set to show unique warnings only
            unique_warnings = "\n".join(sorted(list(set(warnings))))
            print("--- Build Element Database Warnings --- \n" + unique_warnings)


    def build_relationship_map(self):
        """Builds a cache for quick lookup of relationships for each element."""
        self.relationship_map = {}
        if self.model is None:
            return
        
        # Initialize map for all non-relationship elements
        for el in self.model.findall(".//element"):
            el_id = el.get("id")
            etype = el.get(f"{{{XSI}}}type", "")
            if el_id and "Relationship" not in etype:
                self.relationship_map[el_id] = []

        # Populate map with relationships
        for rel in self.find_all_relationships():
            source_id = rel.get("source")
            target_id = rel.get("target")
            rel_type = rel.get(f"{{{XSI}}}type", "").split(":")[-1]

            if source_id and source_id in self.relationship_map and target_id:
                self.relationship_map[source_id].append({'id': target_id, 'type': rel_type, 'direction': 'out'})
            
            if target_id and target_id in self.relationship_map and source_id:
                self.relationship_map[target_id].append({'id': source_id, 'type': rel_type, 'direction': 'in'})

    def calculate_relationship_counts(self):
        """Calculates incoming and outgoing relationship counts for each element."""
        if self.model is None:
            self.relationship_counts = {}
            return

        counts = {}
        # Initialize all elements with zero counts
        for el in self.model.findall(".//element"):
            el_id = el.get("id")
            if el_id:
                counts[el_id] = {'in': 0, 'out': 0}

        # Iterate through relationships and increment counts
        for rel in self.model.findall(".//element"):
            rel_type = rel.get(f"{{{XSI}}}type", "")
            if rel_type and rel_type.split(":")[-1] in RELATIONSHIP_TYPES:
                source_id = rel.get("source")
                target_id = rel.get("target")
                if source_id and source_id in counts:
                   
                    counts[source_id]['out'] += 1
                if target_id and target_id in counts:
                    counts[target_id]['in'] += 1
        
        self.relationship_counts = counts
    # --- TreeView ---
    def refresh_tree(self, filter_text=""):
        self.treeview.delete(*self.treeview.get_children())
        if self.model is None:
            return
        
        filter_text = filter_text.lower()

        root_label = f"archimate:model | {self.model.get('name','')}"
        root_id = self.treeview.insert("", "end", text=root_label, open=True, values=("model",))
        for folder in self.model.findall("folder"):
            fname = folder.get("name", "Folder")
            ftype = folder.get("type", "")
            folder_id = self.treeview.insert(root_id, "end", text=f"{fname} ({ftype})", values=("folder", folder.get("id","")), open=bool(filter_text))
            for el in folder.findall("element"):
                etype_full = el.get(f"{{{XSI}}}type", "")
                etype = etype_full.split(":")[-1] if ":" in etype_full else etype_full
                name = el.get("name","")
                el_id = el.get("id","")
                if filter_text and filter_text not in name.lower():
                    continue

                counts = self.relationship_counts.get(el_id, {'in': 0, 'out': 0})
                el_label = f"[{counts['in']}] > {name} < [{counts['out']}]" if name else f"{etype}"
                el_node = self.treeview.insert(folder_id, "end", text=el_label, values=("element", el_id))
                # The following block is commented out as it was from a previous version
                # for child in list(el):
                #     ctag = child.tag
                #     ctext = (child.text or "").strip()
                #     if ctext:
                #         child_label = f"{ctag}: {ctext}"
                #         self.treeview.insert(el_node, "end", text=child_label)
        self.update_xml_output_panel()

    def search_tree(self, *args):
        # Filters the treeview based on the search entry."""
        self.refresh_tree(self.search_var.get())

    def on_tree_select(self, event):
        sel = self.treeview.selection()
        if not sel:
            return
        node = sel[0]
        self.details_text.config(state="normal")
        self.details_text.delete("1.0", "end")
        item_text = self.treeview.item(node, "text")
        self.details_text.insert("end", item_text + "\n\n")
        vals = self.treeview.item(node, "values")
        if vals and vals[0] == "element":
            el_id = vals[1]
            el = self.find_element_by_id(el_id)
            if el is not None:
                for k,v in el.attrib.items():
                    self.details_text.insert("end", f"{k} = {v}\n")
                for child in list(el):
                    ctag = child.tag
                    ctext = (child.text or "").strip()
                    self.details_text.insert("end", f"{ctag}: {ctext}\n")
        self.details_text.config(state="disabled")

    # --- Paste Area handling ---
    def clear_paste(self):
        self.paste_text.delete("1.0", "end")
        self.update_staged_preview()
        self.update_button_states()

    def quick_add_to_paste(self):
        t = self.type_var.get().strip()
        name = self.name_entry.get().strip()
        desc = self.desc_entry.get().strip()
        if not t or not name:
            messagebox.showwarning("Missing", "Please provide both Type and Name for Quick Add.")
            return
        line = f"{t} | {name}"
        if desc:
            line += f" | description={desc}"
        cur = self.paste_text.get("1.0", "end").rstrip()
        if cur:
            self.paste_text.insert("end", "\n" + line)
        else:
            self.paste_text.insert("end", line)
        self.update_staged_preview()
        self.name_entry.delete(0, "end")
        self.desc_entry.delete(0, "end")

    def on_paste_modified(self, event=None):
        if self.paste_text.edit_modified():
            self.update_staged_preview()
            self.update_button_states()
            self.paste_text.edit_modified(False)

    def update_staged_preview(self):
        self.preview_text.config(state="normal")
        self.preview_text.delete("1.0", "end")
        text = self.paste_text.get("1.0", "end").strip()
        if not text:
            self.preview_text.insert("end", "(no staged entries)\n")
            self.preview_text.config(state="disabled")
            return

        # Build a temp element_db for preview so relationships can resolve IDs
        temp_db = {k: list(v) for k, v in self.element_db.items()} # Make a mutable copy
        lines = [l.strip() for l in text.splitlines() if l.strip() and not l.startswith("#")]
        snippets = []

        # First pass: assign IDs to new elements
        for ln in lines:
            parts = [p.strip() for p in ln.split("|")]
            if len(parts) < 2:
                continue
            raw_type = parts[0]
            short = raw_type.split(":")[-1]
            if short.endswith("Relationship") or short in RELATIONSHIP_TYPES:
                continue
            name = parts[1]
            name_lower = name.lower()
            
            # Check if an element with this name and type already exists
            is_duplicate = False
            for _, existing_type in temp_db.get(name_lower, []):
                if existing_type.split(":")[-1] == short:
                    is_duplicate = True
                    break
            
            if not is_duplicate:
                new_id = generate_id()
                if name_lower not in temp_db:
                    temp_db[name_lower] = []
                temp_db[name_lower].append((new_id, f"archimate:{raw_type}"))

        # Second pass: generate XML snippets
        for ln in lines:
            parts = [p.strip() for p in ln.split("|")]
            if len(parts) < 2:
                snippets.append(f"<!-- Could not parse: {ln} -->")
                continue
            raw_type = parts[0]
            short = raw_type.split(":")[-1]
            if short.endswith("Relationship") or short in RELATIONSHIP_TYPES:
                src_name = parts[1]
                extras = {}
                for extra in parts[2:]:
                    if "=" in extra:
                        k,v = extra.split("=",1)
                        extras[k.strip()] = v.strip()
                tgt_name = extras.get("target")
                descr = extras.get("description")
                
                # For preview, we just pick the first match
                src_id = (temp_db.get(src_name.lower(), [None])[0] or ("[source_id]",))[0]
                tgt_id = (temp_db.get(tgt_name.lower(), [None])[0] or ("[target_id]",))[0] if tgt_name else "[target_id]"

                snippet = f'<element xsi:type="archimate:{short}"'
                snippet += f' source="{src_id}" target="{tgt_id}"'
                if descr:
                    snippet += f' description="{descr}"'
                snippet += ' />'
                snippets.append(snippet)
            else:
                name = parts[1]
                extras = {}
                for extra in parts[2:]:
                    if "=" in extra:
                        k,v = extra.split("=",1)
                        extras[k.strip()] = v.strip()
                doc = extras.get("description")
                
                # Find the ID from the temp DB, picking the first match for the preview
                el_id = (temp_db.get(name.lower(), [None])[0] or ("[new_id]",))[0]

                snippet = f'<element xsi:type="archimate:{raw_type}" name="{name}" id="{el_id}"'
                if doc:
                    snippet += f'>\n  <documentation>{doc}</documentation>\n</element>'
                else:
                    snippet += ' />'
                snippets.append(snippet)
        for s in snippets:
            self.preview_text.insert("end", s + "\n")
        self.preview_text.config(state="disabled")

    # --- Insert / Commit ---
    def insert_from_paste(self):
        if self.model is None:
            messagebox.showwarning("No model", "Open an .archimate file first.")
            return
        paste = self.paste_text.get("1.0", "end").strip()
        if not paste:
            messagebox.showinfo("Nothing to insert", "Paste Area is empty.")
            return
        lines = [l.strip() for l in paste.splitlines() if l.strip() and not l.startswith("#")]
        if not lines:
            messagebox.showinfo("Nothing to insert", "Paste Area is empty.")
            return

        self.save_history()
        created_elements = []
        relationships_to_create = []
        self.create_default_folders()

        # First pass: Parse all lines, create elements, and queue relationships
        for ln in lines:
            parts = [p.strip() for p in ln.split("|")]
            if len(parts) < 2:
                continue

            raw_type = parts[0]
            name_or_source = parts[1]

            # Parse all key-value attributes from the line
            extras = {}
            for extra in parts[2:]:
                if "=" in extra:
                    k, v = extra.split("=", 1)
                    extras[k.strip()] = v.strip()

            # A line is a relationship if and only if it has a 'target' attribute.
            if 'target' in extras:
                relationships_to_create.append({
                    "type": raw_type.split(":")[-1],
                    "source_name": name_or_source,
                    "source_type": extras.get("source_type"), # Capture the new source type hint
                    "target_name": extras.get("target"),
                    "target_type": extras.get("target_type"), # Capture the target type hint
                    "description": extras.get("description")
                })
            else:  # It's an element
                name = name_or_source
                
                # Corrected duplicate check: An element is only a duplicate if both its name AND type match.
                is_duplicate = False
                potential_matches = self.element_db.get(name.lower(), [])
                for _, existing_type_full in potential_matches:
                    if existing_type_full.split(":")[-1] == raw_type.split(":")[-1]:
                        is_duplicate = True
                        break
                
                if is_duplicate:
                    continue # Skip true duplicates (same name, same type)

                etype_full = f"archimate:{raw_type}"
                new_el_id = generate_id()
                folder = self.get_folder_for_type(raw_type)

                if folder is None:
                    print(f"Warning: Could not find or create a folder for type '{raw_type}'. Skipping element '{name}'.")
                    continue

                attribs = {f"{{{XSI}}}type": etype_full, "name": name, "id": new_el_id}
                new_el = ET.SubElement(folder, "element", attribs)
                doc_text = extras.get("description")
                if doc_text:
                    doc_el = ET.SubElement(new_el, "documentation")
                    doc_el.text = doc_text
                
                # Update the local name->ID cache immediately for subsequent relationship lookups
                name_lower = name.lower()
                if name_lower not in self.element_db:
                    self.element_db[name_lower] = []
                self.element_db[name_lower].append((new_el_id, etype_full))
                created_elements.append((name, new_el_id))

        # Second pass: create relationships
        rel_folder = self.get_or_create_relations_folder()
        for rel in relationships_to_create:
            rtype = rel["type"]
            src_name = rel["source_name"]
            src_type = rel["source_type"]
            tgt_name = rel["target_name"]
            tgt_type = rel["target_type"]
            descr = rel.get("description")

            # --- Robust Element Lookup Helper ---
            def find_element_info(name, element_type_hint=None):
                potential_matches = self.element_db.get(name.lower(), [])
                if not potential_matches: 
                    print(f"Warning: Could not find any element named '{name}'.")
                    return None
                
                if len(potential_matches) == 1: 
                    return potential_matches[0]
                
                # Ambiguity exists, try to resolve with type hint
                if element_type_hint:
                    hint_full = f"archimate:{element_type_hint}"
                    for match in potential_matches:
                        if match[1] == hint_full:
                            return match
                    print(f"Warning: Found elements named '{name}', but none of type '{element_type_hint}'.")
                    return None
                
                print(f"Warning: Ambiguous element name '{name}' and no type hint provided. Skipping relationship.")
                return None

            src_info = find_element_info(src_name, src_type)
            tgt_info = find_element_info(tgt_name, tgt_type) if tgt_name else None

            if not src_info or not tgt_info:
                continue # Warnings are printed inside the helper
            
            src_id, _ = src_info
            tgt_id, _ = tgt_info
            rel_id = generate_id()
            rel_attribs = {
                f"{{{XSI}}}type": f"archimate:{rtype}",
                "id": rel_id,
                "source": src_id,
                "target": tgt_id
            }
            rel_el = ET.SubElement(rel_folder, "element", rel_attribs)
            if descr:
                doc_el = ET.SubElement(rel_el, "documentation")
                doc_el.text = descr

        if created_elements or relationships_to_create:
            self.dirty = True

        self.build_element_database() # Rebuild after adding all elements
        self.build_relationship_map()
        self.calculate_relationship_counts()
        self.refresh_tree()
        
        # Clear the paste area now that the content has been committed
        if created_elements or relationships_to_create:
            self.paste_text.delete("1.0", "end")

        self.update_staged_preview()
        self.update_xml_output_panel()
        self.update_button_states()
        messagebox.showinfo("Inserted", f"Inserted {len(created_elements)} elements and {len(relationships_to_create)} relationships.")

    # --- Helper methods ---
    def find_element_by_id(self, el_id):
        if self.model is None:
            return None
        return self.model.find(f".//*[@id='{el_id}']")

    def _find_and_remove_element(self, element_to_remove):
        """Helper to find the parent folder of an element and remove it."""
        if self.model is None or element_to_remove is None:
            return False
        # An element's parent is a folder.
        for folder in self.model.findall("folder"):
            try:
                folder.remove(element_to_remove)
                return True # Successfully found and removed
            except ValueError:
                pass # Not in this folder, continue searching
        return False # Element not found in any folder

    def _show_report_window(self, title, content):
        """
        Displays a resizable window with selectable, scrollable text content for reports.
        """
        report_window = tk.Toplevel(self.root)
        report_window.title(title)
        report_window.geometry("800x600")

        # Configure grid layout for the window
        report_window.rowconfigure(0, weight=1)
        report_window.columnconfigure(0, weight=1)

        # Main frame with padding
        main_frame = tk.Frame(report_window, padx=10, pady=10)
        main_frame.grid(row=0, column=0, sticky="nsew")
        main_frame.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)

        # Text widget
        report_text = tk.Text(main_frame, wrap="none", font=("Consolas", 10))
        report_text.grid(row=0, column=0, sticky="nsew")

        # Scrollbars
        y_scroll = tk.Scrollbar(main_frame, orient="vertical", command=report_text.yview)
        y_scroll.grid(row=0, column=1, sticky="ns")
        x_scroll = tk.Scrollbar(main_frame, orient="horizontal", command=report_text.xview)
        x_scroll.grid(row=1, column=0, sticky="ew")

        report_text.config(yscrollcommand=y_scroll.set, xscrollcommand=x_scroll.set)

        # Insert content and make read-only
        report_text.insert("1.0", content)
        report_text.config(state="disabled")

        # Make modal
        report_window.transient(self.root)
        report_window.grab_set()
        self.root.wait_window(report_window)

    def get_folder_for_type(self, element_type):
        short = element_type.split(":")[-1]
        # The check for relationship types is now handled robustly in the main insert_from_paste function.
        # Removing the redundant check here prevents silent failures due to misconfiguration.
        folder_name = FOLDER_MAP.get(short, "Other")
        for folder in self.model.findall("folder"):
            if folder.get("name") == folder_name:
                return folder
        return self.create_folder(folder_name, folder_name.lower())

    def get_or_create_relations_folder(self):
        for folder in self.model.findall("folder"):
            if folder.get("type") == "relations":
                return folder
        return self.create_folder("Relations", "relations")

    def create_folder(self, name, folder_type):
        folder_id = generate_id()
        attribs = {"name": name, "id": folder_id, "type": folder_type}
        return ET.SubElement(self.model, "folder", attribs)

    def create_default_folders(self):
        folders = [
            ("Strategy", "strategy"),
            ("Business", "business"),
            ("Application", "application"),
            ("Technology & Physical", "technology"),
            ("Motivation", "motivation"),
            ("Implementation & Migration", "implementation_migration"),
            ("Other", "other"),
            ("Relations", "relations"),
            ("Views", "diagrams")
        ]
        for name, ftype in folders:
            found = False
            for folder in self.model.findall("folder"):
                if folder.get("type") == ftype:
                    found = True
                    break
            if not found:
                self.create_folder(name, ftype)

    def remove_relationships_from_other(self):
        for folder in self.model.findall("folder"):
            if folder.get("type") == "other":
                to_remove = []
                for el in folder.findall("element"):
                    etype_full = el.get(f"{{{XSI}}}type", "")
                    short = etype_full.split(":")[-1]
                    if short.endswith("Relationship") or short in RELATIONSHIP_TYPES:
                        to_remove.append(el)
                for el in to_remove:
                    folder.remove(el)

    def update_xml_output_panel(self):
        if not hasattr(self, "xml_output_text"):
            return
        if self.model is None:
            self.xml_output_text.config(state="normal")
            self.xml_output_text.delete("1.0", "end")
            self.xml_output_text.insert("end", "(no model loaded)")
            self.xml_output_text.config(state="disabled")
            return
        xml_str = ET.tostring(self.model, encoding='utf-8')
        dom = minidom.parseString(xml_str)
        pretty_xml = dom.toprettyxml(indent="  ")
        lines = pretty_xml.split('\n')
        if lines and lines[0].startswith('<?xml'):
            lines = lines[1:]
        pretty_xml = '\n'.join(lines).strip()
        self.xml_output_text.config(state="normal")
        self.xml_output_text.delete("1.0", "end")
        self.xml_output_text.insert("end", pretty_xml)
        self.xml_output_text.config(state="disabled")

    # --- History / Undo ---
    def save_history(self):
        if self.model is None:
            return
        self.history.append(copy.deepcopy(self.model))
        if len(self.history) > 40:
            self.history.pop(0)

    def undo(self):
        if not self.history:
            messagebox.showinfo("Undo", "No undo history.")
            return
        snapshot = self.history.pop()
        self.model = snapshot
        self.tree = ET.ElementTree(self.model)
        self.dirty = True # Undoing is a change
        self.build_element_database()
        self.build_relationship_map()
        self.calculate_relationship_counts()
        self.refresh_tree()
        self.update_xml_output_panel()
        self.update_button_states()
        messagebox.showinfo("Undo", "Reverted one step.")

    # --- 3D Visualization methods have been moved to the ThreeDViewer class ---

    def get_element_relationships(self, el_id):
        """
        Returns a list of relationships for a given element ID using the pre-built map.
        """
        return self.relationship_map.get(el_id, [])


if __name__ == "__main__":
    root = tk.Tk()
    app = ArchiIngestorApp(root)

    root.mainloop()
